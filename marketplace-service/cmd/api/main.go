package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/Pancreasz/Undead-Miles/marketplace/internal/database"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/cors"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Config struct to hold our Database Queries
type apiConfig struct {
	DB *database.Queries
}

func main() {
	// 1. Database Connection String (Matches docker-compose)
	dbURL := "postgres://postgres:cpre888@localhost:5555/undeadmiles?sslmode=disable"

	// 2. Connect to the Database
	// We use a Connection Pool (pgxpool) for better performance
	connPool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		log.Fatal("Cannot connect to database:", err)
	}
	defer connPool.Close()

	// 3. Initialize sqlc
	// This 'db' variable now has all your methods: db.CreateTrip, db.ListTrips...
	db := database.New(connPool)

	// 4. Create the API Config
	apiCfg := &apiConfig{
		DB: db,
	}

	// 5. Setup Router (Chi)
	r := chi.NewRouter()

	// Basic CORS (Allows frontend to talk to backend)
	r.Use(cors.Handler(cors.Options{
		AllowedOrigins: []string{"*"},
		AllowedMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
	}))

	// 6. Define Routes
	r.Get("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Marketplace Service is OK!"))
	})

	// We link the route to our handler method
	r.Get("/trips", apiCfg.handlerListTrips)
	r.Post("/trips", apiCfg.handlerCreateTrip)

	// 7. Start Server
	port := "8080"
	fmt.Printf("Marketplace Service running on port %s...\n", port)
	log.Fatal(http.ListenAndServe(":"+port, r))
}

// --- Handlers (Usually these go in internal/handler, keeping here for simplicity now) ---

func (cfg *apiConfig) handlerListTrips(w http.ResponseWriter, r *http.Request) {
	// Call the method generated by sqlc
	trips, err := cfg.DB.ListTrips(r.Context())
	if err != nil {
		http.Error(w, "Failed to fetch trips", http.StatusInternalServerError)
		return
	}

	// Convert Go Structs -> JSON
	respondWithJSON(w, 200, trips)
}

func (cfg *apiConfig) handlerCreateTrip(w http.ResponseWriter, r *http.Request) {
	// In a real app, you would parse the JSON body here.
	// For now, we return a placeholder to prove the router works.
	respondWithJSON(w, 200, map[string]string{"status": "Create Trip Not Implemented Yet"})
}

// Helper to send JSON responses
func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(payload)
}
